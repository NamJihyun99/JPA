### 4. SQL 쿼리 힌트 사용
### SQL 쿼리 힌트??
* 힌트란 일종의 지시 구문. SQL문 실행을 위한 데이터를 스캐닝하는 경로, 조인 방법 등을 알려주기 위해 SQL사용자가 SQL 구문에 작성하는 것을 뜻한다.
오라클이 항상 최적의 실행 경로를 만들어 내기는 불가능하기 때문에 직접 최적의 실행 경로를 작성해 주는 것이다.(https://velog.io/@gillog/SQL-Plan-Hint)
* JPA는 디비에 SQL 힌트 기능을 제공하지 않는다. 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다. 
* addQueryHint() 메소드를 사용해야 한다.
```java
Session session = em.unwrap(Session.class); // 하이버네이트 직접 사용

List<Member> list = session.createQuery("select m from Member m")
                            .addQueryHint("FULL (MEMBER)") // 힌트 추가
                            .list();
```
```sql
select /*+ FULL (MEMBER) */ m.id, m.name from Member m;f
```
* 현재는 오라클 방언에만 힌트가 적용되어 있다.
* 다른 디비에서 힌트를 사용하려면 각 방언에서 org.hibernate.dialect.Dialect에 있는 메소드를 오버라이딩 해야한다.
```java
public String getQueryHintString(String query, List<String> hints){
  return query;
}
```
  
### 5. 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
#### 1. 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치
#### 쓰기 지연??
* 영속성 컨텍스트에 변경이 발생했을 때, 바로 데이터베이스로 쿼리를 보내지 않고 SQL 쿼리를 버퍼에 모아놨다가, 영속성 컨텍스트가 flush 하는 시점에 모아둔 SQL 쿼리를 데이터베이스로 보내는 기능(https://soongjamm.tistory.com/150)
```sql
insert(member1); // insert into member...
insert(member2); // insert into member...
insert(member3); // insert into member...
insert(member4); // insert into member...
commit(); // sql을 직접 다루는 경우
```
* 5번의 insert + 1번의 commit -> 6번 디비와 통신
* 최적화하려면 5번의 insert문을 모아서 한 번에 디비로 보내면 된다. -> JDBC가 제공하는 sql 배치 기능 사용하면 가능!
-> 하지만 코드 대규모 수정 필요..! -> 수백/수천건의 데이터 변경하는 특수한 상황에 sql 배치 기능 사용
* 네트워크 호출 한 번은 단순한 메소드를 수 만번 호출하는 것 보다 더 큰 비용이 든다.
* JPA는 플러시 기능이 있으므로 SQL 배치 기능을 쉽게 사용 가능하다.

```SQL
// 하이버네이트에서 SQL 배치 적용하는 방법(SQL Server 엔진에서 정해진 시간에, 정해진 작업을 수행하도록 하는 작업을 말한다.(https://mozi.tistory.com/383))
<property name="hibernate.jdbc.batch_size" value="50"/> // 50건 씩 보아서 sql 배치 실행

em.persist(new Member());
em.persist(new Member());
em.persist(new Member());
em.persist(new Member());
em.persist(ner Child()); // 다른 sql이므로 sql 배치가 다시 시작됨
em.persist(new Member());
em.persist(new Member());

// 1,2,3,4를 모아서 하나의 sql 배치 + 5 실행 + 6,7 모아서 실행 --> 총 3번의 sql 배치 실행

```
#### 엔티티가 영속 상태가 되려면 식별자 꼭 필요. 그런데 IDENTITY 식별자 생성 전략은 엔티티를 디비에 저장해야 식별자를 구할 수 있으므로
#### em.persist()를 호출하는 즉시 insert sql이 디비에 전달된다. 따라서 쓰기 지연을 활용한 성능 최적화 불가

#### 2. 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성
* 트랜잭션을 지원하는 쓰기 지연 + 변경 감지 기능 ==> 성능과 개발 편의성 둘 다 잡기 가능!
#### 그러나, 진짜는 데이터베이스 row에 lock이 걸리는 시간 최소화라는 점!
