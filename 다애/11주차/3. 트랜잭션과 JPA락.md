## 3. JPA 락 사용
> JPA를 사용할 때 추천하는 전략은 READ COMMITED 트랜잭션 격리 수준 + 낙관적 버전 관리

* 락을 적용할 수 있는 위치
```JAVA
1. EntityManager.lock(), EntityManager.find(), EntityManager.refresh()
2. Query.setLockmode() (TypeQuery포함)
3. @NamedQuery
```
```java
// 조회하면서 즉시 락 걸기
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);
// 필요시에 락 걸기
Board board = em.find(Board.class, id);
..
em.lock(board, LockModeType.OPTIMISTIC);
```
* JPA가 제공하는 락 옵션은 javax.persistence.LockModeType에 정의되어 있다.
![image](https://user-images.githubusercontent.com/68958749/185322242-9f6af3bb-2cb5-4c9d-8eb6-fdd61e0302d9.png)

### 3.1 JPA 낙관적 락
> JPA가 제공하는 낙관적 락은 버전(@Version)을 사용한다. 따라서 낙관적 락을 사용하려면 버전이 있어야 한다.
* 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다.
* 낙관적 락에서 발생하는 예외는 아래와 같다.
1. javax.persistence.OptimisticLockException(JPA 예외)
2. org.hibernate.StaleObjectStateException(하이버네이트 예외)
3. org.springframework.orm.ObjectOptimisticLockingFailureException(스프링 예외 추상화)

#### 1. NONE
> 락 옵션을 적용하지 않아도 엔티티에 @Version이 적용된 필드만 있으면 낙관적 락이 적용된다.
1. 용도 : 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경(삭제)되지 않아야한다. 조회 시점부터 수정 시점까지 보장
2. 동작 : 엔티티 수정 시, 버전을 체크하면서 버전을 증가한다.(update쿼리 사용) 이 때 디비의 버전 값이 현재 버전이 아니면 예외 발생
3. 이점 : 두 번의 갱실 분실 문제를 예방한다.

#### 2. OPTIMISTIC
> 이 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한다. 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음 보장
1. 용도 : 조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에의해 변경되지 않아야 한다. 즉, 조회 시점부터 트랜잭션이 끝날 때까지 조회한 엔티티가 변경되지
않음을 보장
2. 동작 : 트랜잭션을 커밋할 때 버전 정보를 조회해서(select쿼리 사용) 현재 엔티티 버전과 같은지 검증하고 같지 않으면 예외 발생
3. 이점 : DIRTY READ와 NON-REPEATABLE READ를 방지한다.

```JAVA
// T1조회 title="제목A", version=1
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);

// 중간에 T2에서 해당 게시물 수정해서 title="제목C", version=2로 증가

// T1 커밋 시점에 버전 정보 검증, 예외 발생
// (데이터베이스 version=2, 엔티티 version=1
tx.commit();
```
