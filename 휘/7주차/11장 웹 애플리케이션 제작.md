# 11장 웹 애플리케이션 제작

**목표**

스프링 프레임워크와 JPA를 사용해서 실제 웹 애플리케이션을 제작해보자. 

**목차**

1. 프로젝트 환경설정
2. 도메인 모델과 테이블 설계
3. 애플리케이션 구현

# 프로젝트 환경설정

핵심 라이브러리

- 스프링 MVC
- 스프링 ORM
- JPA, 하이버네이트

기타 라이브러리

- H2
- 커넥션 풀
- WEB: 서블릿, JSP 관련
- 로깅
- 테스트

- pom.xml 코드
    
    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>jpabook</groupId>
        <artifactId>ch11-jpa-shop</artifactId>
        <version>1.0-SNAPSHOT</version>
        <name>jpa-shop</name>
        <packaging>war</packaging>
    
        <properties>
    
            <!-- 기본 설정 -->
            <java.version>1.6</java.version>
            <!-- 프로젝트 코드 인코딩 설정 -->
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    
            <!-- 스프링 프레임워크 버전 -->
            <spring-framework.version>4.1.6.RELEASE</spring-framework.version>
            <!-- JPA, 하이버네이트 버전 -->
            <hibernate.version>4.3.10.Final</hibernate.version>
            <!-- 데이터베이스 버전 -->
            <tomcat-jdbc.version>7.0.57</tomcat-jdbc.version>
            <h2db.version>1.4.187</h2db.version>
            <!-- JSP, WEB 버전 -->
            <jsp.version>2.2</jsp.version>
            <jstl.version>1.2</jstl.version>
            <servlet.version>3.0.1</servlet.version>
            <!-- 로그 버전 -->
            <logback.version>1.1.1</logback.version>
            <slf4j.version>1.7.6</slf4j.version>
            <!-- 테스트 버전 -->
            <junit.version>4.12</junit.version>
    
        </properties>
    
        <dependencies>
    
            <!-- 스프링 MVC -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>${spring-framework.version}</version>
            </dependency>
    
            <!-- 스프링 ORM -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-orm</artifactId>
                <version>${spring-framework.version}</version>
            </dependency>
    
            <!-- JPA, 하이버네이트 -->
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-entitymanager</artifactId>
                <version>${hibernate.version}</version>
            </dependency>
    
            <!-- H2 데이터베이스 -->
            <dependency>
                <groupId>com.h2database</groupId>
                <artifactId>h2</artifactId>
                <version>${h2db.version}</version>
                <scope>runtime</scope>
            </dependency>
    
            <!-- 커넥션 풀 -->
            <dependency>
                <groupId>org.apache.tomcat</groupId>
                <artifactId>tomcat-jdbc</artifactId>
                <version>${tomcat-jdbc.version}</version>
                <scope>compile</scope>
            </dependency>
    
            <!-- WEB -->
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>jstl</artifactId>
                <version>${jstl.version}</version>
                <scope>runtime</scope>
            </dependency>
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>javax.servlet-api</artifactId>
                <version>${servlet.version}</version>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>javax.servlet.jsp</groupId>
                <artifactId>javax.servlet.jsp-api</artifactId>
                <version>2.3.1</version>
                <scope>provided</scope>
            </dependency>
    
            <!-- 로깅 SLF4J & LogBack -->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>${slf4j.version}</version>
                <scope>compile</scope>
            </dependency>
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>${logback.version}</version>
                <scope>runtime</scope>
            </dependency>
    
            <!-- 테스트 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-test</artifactId>
                <version>${spring-framework.version}</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>${junit.version}</version>
                <scope>test</scope>
            </dependency>
    
        </dependencies>
    
    	<build>
    		<plugins>
    	      <plugin>
    	        <groupId>org.apache.maven.plugins</groupId>
    	        <artifactId>maven-compiler-plugin</artifactId>
    	        <version>3.1</version>
    	        <configuration>
    	          <source>${java.version}</source>
    	          <target>${java.version}</target>
    	        </configuration>
    	      </plugin>
    	      
    	      <plugin>
    	        <groupId>org.apache.tomcat.maven</groupId>
    	        <artifactId>tomcat7-maven-plugin</artifactId>
    	        <version>2.2</version>
    	        <configuration>
    	        	<path>/</path>
    	       	    <uriEncoding>UTF-8</uriEncoding>
    	        </configuration>
    	      </plugin>
    	                 	      
    	    </plugins>
    	</build>
    </project>
    ```
    

# 도메인 모델과 테이블 설계

## 요구사항 분석

- 회원 기능
    - 회원 등록
    - 회원 조회
- 상품 기능
    - 상품 등록
    - 상품 수정
    - 상품 조회
- 주문 기능
    - 상품 주문
    - 주문 내역 조회
    - 주문 취소
- 기타 요구사항
    - 상품 종류는 도서, 음반, 영화가 있다.
    - 상품은 카테고리로 구분할 수 있다.
    - 상품 주문 시 배송 정보를 입력할 수 있다.

## UML

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A1%E1%86%A8%2073c4088a9ad74187b4658571d0bb562c/Untitled.png)

- Order과 Item: 다대다 관계라서 OrderItem 중간테이블을 둠
- Member와 Order: 일대다 관계
- Order와 Delivery: 일대일 관계
- Item → Album, Book, Movie: 상속 구조
- Member와 Address: Member는 임베디드 타입인 Address를 가진다
- Catergory와 Item: 다대다 관계
- Catergory: 카테고리 내부에서도 상하관계가 있음. 자식은 List로 가지고, 부모는 하나의 Category를 가짐

## ERD

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A1%E1%86%A8%2073c4088a9ad74187b4658571d0bb562c/Untitled%201.png)

- MEMBER: 회원 엔티티의 Address 임베디드 타입 정보가 회원 테이블에 그대로 들어간다. DELIVERY도 마찬가지
- ITEM: 앨범, 도서, 영화 타입을 통합해서 하나의 테이블로 만들었다. DTYPE으로 타입을 구분한다.
- MEMBER와 ORDER의 연관관계 매핑: 일대다 양방향이므로 FK를 가진 ORDER 쪽이 연관관계의 주인이다.
- ORDER_ITEM과 ORDER의 연관관계 매핑: 다대일 양방향이므로 FK를 가진 ORDER_ITEM 쪽이 연관관계의 주인이다.
- ORDER_ITEM과 ITEM의 연관관계 매핑: 다대일 단방향이므로 OrderItem.item과 ORDER_ITEM.ITEM_ID와 매핑한다.
- ORDER과 DELIVERY: 일대일 양방향이므로 어느쪽에서 매핑해도 상관 없다.
- CATEGORY와 ITEM: 다대다 (실무에서는 잘 사용하지 않음)

## [참고] 테이블 기본키 이름과 식별자 이름

- 테이블 기본키: 테이블명_ID
    - FK를 봐야만 어느 소속인지 알 수 있음
    - 테이블 이름을 포함하는 것이 유지보수에 편함
- 식별자 이름: id
    - 참조로 어느 소속인지 알 수 있음

## ⭐엔티티 코드⭐

- Member
    
    ```java
    @Entity
    public class Member {
    
        @Id @GeneratedValue
        @Column(name = "MEMBER_ID")
        private Long id;
    
        private String name;
    
        @Embedded
        private Address address;
    
        @OneToMany(mappedBy = "member")
        private List<Order> orders = new ArrayList<Order>();
    
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Address getAddress() {
            return address;
        }
    
        public void setAddress(Address address) {
            this.address = address;
        }
    
        public List<Order> getOrders() {
            return orders;
        }
    
        public void setOrders(List<Order> orders) {
            this.orders = orders;
        }
    
        @Override
        public String toString() {
            return "Member{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", address=" + address +
                    '}';
        }
    }
    ```
    
    - List<Order>: 일대다, 연관관계의 주인은 Order
    - Address: 임베디드 타입
    
- Order
    
    ```java
    @Entity
    @Table(name = "ORDERS")
    public class Order {
    
        @Id @GeneratedValue
        @Column(name = "ORDER_ID")
        private Long id;
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "MEMBER_ID")
        private Member member;      //주문 회원
    
        @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
        private List<OrderItem> orderItems = new ArrayList<OrderItem>();
    
        @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
        @JoinColumn(name = "DELIVERY_ID")
        private Delivery delivery;  //배송정보
    
        private Date orderDate;     //주문시간
    
        @Enumerated(EnumType.STRING)
        private OrderStatus status;//주문상태
    
        //==생성 메서드==//
        public static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems) {
    
            Order order = new Order();
            order.setMember(member);
            order.setDelivery(delivery);
            for (OrderItem orderItem : orderItems) {
                order.addOrderItem(orderItem);
            }
            order.setStatus(OrderStatus.ORDER);
            order.setOrderDate(new Date());
            return order;
        }
    
        //==비즈니스 로직==//
        /** 주문 취소 */
        public void cancel() {
    
            if (delivery.getStatus() == DeliveryStatus.COMP) {
                throw new RuntimeException("이미 배송완료된 상품은 취소가 불가능합니다.");
            }
    
            this.setStatus(OrderStatus.CANCEL);
            for (OrderItem orderItem : orderItems) {
                orderItem.cancel();
            }
        }
    
        //==조회 로직==//
        /** 전체 주문 가격 조회 */
        public int getTotalPrice() {
            int totalPrice = 0;
            for (OrderItem orderItem : orderItems) {
                totalPrice += orderItem.getTotalPrice();
            }
            return totalPrice;
        }
    
        //==연관관계 메서드==//
        public void setMember(Member member) {
            this.member = member;
            member.getOrders().add(this);
        }
    
        public void addOrderItem(OrderItem orderItem) {
            orderItems.add(orderItem);
            orderItem.setOrder(this);
        }
    
        public void setDelivery(Delivery delivery) {
            this.delivery = delivery;
            delivery.setOrder(this);
        }
    
        //==Getter, Setter==//
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public Member getMember() {
            return member;
        }
    
        public List<OrderItem> getOrderItems() {
            return orderItems;
        }
    
        public void setOrderItems(List<OrderItem> orderItems) {
            this.orderItems = orderItems;
        }
    
        public Delivery getDelivery() {
            return delivery;
        }
    
        public Date getOrderDate() {
            return orderDate;
        }
    
        public void setOrderDate(Date orderDate) {
            this.orderDate = orderDate;
        }
    
        public OrderStatus getStatus() {
            return status;
        }
    
        public void setStatus(OrderStatus status) {
            this.status = status;
        }
    
        @Override
        public String toString() {
            return "Order{" +
                    "id=" + id +
                    ", orderDate=" + orderDate +
                    ", status=" + status +
                    '}';
        }
    }
    ```
    
    - Member: 다대일 관계, 연관관계의 주인은 Order
    - List<OrderItem>: 일대다 관계
        - cascade = CascadeType.All: Order를 변경할 때 OrderItem에 변경사항이 있으면 함께 반영
    - OrderStatus: ENUM 타입
    
- OrderItem
    
    ```java
    @Entity
    @Table(name = "ORDER_ITEM")
    public class OrderItem {
    
        @Id @GeneratedValue
        @Column(name = "ORDER_ITEM_ID")
        private Long id;
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "ITEM_ID")
        private Item item;      //주문 상품
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "ORDER_ID")
        private Order order;    //주문
    
        private int orderPrice; //주문 가격
        private int count;      //주문 수량
    
        //==생성 메서드==//
        public static OrderItem createOrderItem(Item item, int orderPrice, int count) {
    
            OrderItem orderItem = new OrderItem();
            orderItem.setItem(item);
            orderItem.setOrderPrice(orderPrice);
            orderItem.setCount(count);
    
            item.removeStock(count);
            return orderItem;
        }
    
        //==비즈니스 로직==//
        /** 주문 취소 */
        public void cancel() {
            getItem().addStock(count);
        }
    
        //==조회 로직==//
        /** 주문상품 전체 가격 조회 */
        public int getTotalPrice() {
            return getOrderPrice() * getCount();
        }
    
        //==Getter, Setter==//
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public Item getItem() {
            return item;
        }
    
        public void setItem(Item item) {
            this.item = item;
        }
    
        public Order getOrder() {
            return order;
        }
    
        public void setOrder(Order order) {
            this.order = order;
        }
    
        public int getOrderPrice() {
            return orderPrice;
        }
    
        public void setOrderPrice(int buyPrice) {
            this.orderPrice = buyPrice;
        }
    
        public int getCount() {
            return count;
        }
    
        public void setCount(int count) {
            this.count = count;
        }
    
        @Override
        public String toString() {
            return "OrderItem{" +
                    "id=" + id +
                    ", buyPrice=" + orderPrice +
                    ", count=" + count +
                    '}';
        }
    }
    ```
    
    - Order과 Item의 중간 테이블
    - Order: 다대일, 연관관계의 주인은 OrderItem
    - Item: 다대일, 연관관계의 주인은 OrderItem
    
- Item
    
    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    @DiscriminatorColumn(name = "DTYPE")
    public abstract class Item {
    
        @Id @GeneratedValue
        @Column(name = "ITEM_ID")
        private Long id;
    
        private String name;        //이름
        private int price;          //가격
        private int stockQuantity;  //재고수량
    
        @ManyToMany(mappedBy = "items")
        private List<Category> categories = new ArrayList<Category>();
    
        //==Biz Method==//
        public void addStock(int quantity) {
            this.stockQuantity += quantity;
        }
    
        public void removeStock(int quantity) {
            int restStock = this.stockQuantity - quantity;
            if (restStock < 0) {
                throw new NotEnoughStockException("need more stock");
            }
            this.stockQuantity = restStock;
        }
    
        //==Getter Setter==//
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getPrice() {
            return price;
        }
    
        public void setPrice(int price) {
            this.price = price;
        }
    
        public int getStockQuantity() {
            return stockQuantity;
        }
    
        public void setStockQuantity(int stockQuantity) {
            this.stockQuantity = stockQuantity;
        }
    
        public List<Category> getCategories() {
            return categories;
        }
    
        public void setCategories(List<Category> categories) {
            this.categories = categories;
        }
    
        @Override
        public String toString() {
            return "Item{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", price=" + price +
                    '}';
        }
    }
    ```
    
    - 부모 테이블
    - 상속 구조는 SINGLE_TABLE
    - 구분 컬럼은 DTYPE
    
- Book
    
    ```java
    @Entity
    @DiscriminatorValue("B")
    public class Book extends Item {
    
        private String author;
        private String isbn;
    
        public String getAuthor() {
            return author;
        }
    
        public void setAuthor(String author) {
            this.author = author;
        }
    
        public String getIsbn() {
            return isbn;
        }
    
        public void setIsbn(String isbn) {
            this.isbn = isbn;
        }
    
        @Override
        public String toString() {
            return "Book{}";
        }
    }
    ```
    
- Album
    
    ```java
    @Entity
    @DiscriminatorValue("A")
    public class Album extends Item {
    
        private String artist;
        private String etc;
    
        public String getArtist() {
            return artist;
        }
    
        public void setArtist(String artist) {
            this.artist = artist;
        }
    
        public String getEtc() {
            return etc;
        }
    
        public void setEtc(String etc) {
            this.etc = etc;
        }
    
        @Override
        public String toString() {
            return "Album{" +
                    "artist='" + artist + '\'' +
                    ", etc='" + etc + '\'' +
                    '}';
        }
    }
    ```
    
- Movie
    
    ```java
    @Entity
    @DiscriminatorValue("M")
    public class Movie extends Item {
    
        private String director;
        private String actor;
    
        public String getDirector() {
            return director;
        }
    
        public void setDirector(String director) {
            this.director = director;
        }
    
        public String getActor() {
            return actor;
        }
    
        public void setActor(String actor) {
            this.actor = actor;
        }
    
        @Override
        public String toString() {
            return "Movie{" +
                    "director='" + director + '\'' +
                    ", actor='" + actor + '\'' +
                    '}';
        }
    }
    ```
    
- Delivery
    
    ```java
    @Entity
    public class Delivery {
    
        @Id @GeneratedValue
        @Column(name = "DELIVERY_ID")
        private Long id;
    
        @OneToOne(mappedBy = "delivery")
        private Order order;
    
        @Embedded
        private Address address;
    
        @Enumerated(EnumType.STRING)
        private DeliveryStatus status; //ENUM [READY(준비), COMP(배송)]
    
        public Delivery() {
        }
    
        public Delivery(Address address) {
            this.address = address;
            this.status = DeliveryStatus.READY;
        }
    
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public Order getOrder() {
            return order;
        }
    
        public void setOrder(Order order) {
            this.order = order;
        }
    
        public Address getAddress() {
            return address;
        }
    
        public void setAddress(Address address) {
            this.address = address;
        }
    
        public DeliveryStatus getStatus() {
            return status;
        }
    
        public void setStatus(DeliveryStatus status) {
            this.status = status;
        }
    
        @Override
        public String toString() {
            return "Delivery{" +
                    "id=" + id +
                    ", address=" + address +
                    ", status=" + status +
                    '}';
        }
    }
    ```
    
    - Address: 임베디드 타입
    - DeliveryStatus: Enum 타입
    
- Category
    
    ```java
    @Entity
    public class Category {
    
        @Id @GeneratedValue
        @Column(name = "CATEGORY_ID")
        private Long id;
    
        private String name;
    
        @ManyToMany
        @JoinTable(name = "CATEGORY_ITEM",
                joinColumns = @JoinColumn(name = "CATEGORY_ID"),
                inverseJoinColumns = @JoinColumn(name = "ITEM_ID"))
        private List<Item> items = new ArrayList<Item>();
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "PARENT_ID")
        private Category parent;
    
        @OneToMany(mappedBy = "parent")
        private List<Category> child = new ArrayList<Category>();
    
        //==연관관계 메서드==//
        public void addChildCategory(Category child) {
            this.child.add(child);
            child.setParent(this);
        }
    
        public void addItem(Item item) {
            items.add(item);
        }
    
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public List<Item> getItems() {
            return items;
        }
    
        public void setItems(List<Item> items) {
            this.items = items;
        }
    
        public Category getParent() {
            return parent;
        }
    
        public void setParent(Category parent) {
            this.parent = parent;
        }
    
        public List<Category> getChild() {
            return child;
        }
    
        public void setChild(List<Category> child) {
            this.child = child;
        }
    
        @Override
        public String toString() {
            return "Category{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    '}';
        }
    }
    ```
    
    - List<Items>: 조인 테이블을 만들어서 Category와 Item 테이블 간의 연관관계를 지정한다. joinColumns에는 현재 엔티티를 참조하는 FK를, inverseColumns에는 반대 방향 엔티티를 참조하는 FK를 지정한다.
    - 부모 Category: 다대일
    - 자식 Category: 일대다
    
- Address
    
    ```java
    @Embeddable
    public class Address {
    
        private String city;
        private String street;
        private String zipcode;
    
        public Address() {
        }
    
        public Address(String city, String street, String zipcode) {
            this.city = city;
            this.street = street;
            this.zipcode = zipcode;
        }
    
        public String getCity() {
            return city;
        }
    
        public void setCity(String city) {
            this.city = city;
        }
    
        public String getStreet() {
            return street;
        }
    
        public void setStreet(String street) {
            this.street = street;
        }
    
        public String getZipcode() {
            return zipcode;
        }
    
        public void setZipcode(String zipcode) {
            this.zipcode = zipcode;
        }
    
        @Override
        public String toString() {
            return "Address{" +
                    "city='" + city + '\'' +
                    ", street='" + street + '\'' +
                    ", zipcode='" + zipcode + '\'' +
                    '}';
        }
    
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Address)) return false;
    
            Address address = (Address) o;
    
            if (city != null ? !city.equals(address.city) : address.city != null) return false;
            if (street != null ? !street.equals(address.street) : address.street != null) return false;
            if (zipcode != null ? !zipcode.equals(address.zipcode) : address.zipcode != null) return false;
    
            return true;
        }
    
        @Override
        public int hashCode() {
            int result = city != null ? city.hashCode() : 0;
            result = 31 * result + (street != null ? street.hashCode() : 0);
            result = 31 * result + (zipcode != null ? zipcode.hashCode() : 0);
            return result;
        }
    }
    ```
    

# 애플리케이션 구현

일반적으로 많이 사용하는 계층형 구조를 사용한다.

이때 Web 계층은 Domain(엔티티)을 알지만, Domain은 Web 계층을 몰라야 한다.

## 회원 기능

- 회원 등록
- 회원 목록 조회
- MemberRepository
    
    ```java
    @Repository
    public class MemberRepository {
    
        @PersistenceContext
        EntityManager em;
    
        public void save(Member member) {
            em.persist(member);
        }
    
        public Member findOne(Long id) {
            return em.find(Member.class, id);
        }
    
        public List<Member> findAll() {
            return em.createQuery("select m from Member m", Member.class)
                    .getResultList();
        }
    
        public List<Member> findByName(String name) {
            return em.createQuery("select m from Member m where m.name = :name", Member.class)
                    .setParameter("name", name)
                    .getResultList();
        }
    }
    ```
    
    - EntityManager : 컨테이너가 제공하는 EM을 사용한다.
    - save(), findOne: EM이 기본으로 제공하는 메소드를 사용한다.
    - findAll(), findByMame: JPQL 사용
    
- MemberService
    
    ```java
    @Service
    @Transactional
    public class MemberService {
    
        @Autowired
        MemberRepository memberRepository;
    
        /**
         * 회원 가입
         */
        public Long join(Member member) {
    
            validateDuplicateMember(member); //중복 회원 검증
            memberRepository.save(member);
            return member.getId();
        }
    
        private void validateDuplicateMember(Member member) {
            List<Member> findMembers = memberRepository.findByName(member.getName());
            if (!findMembers.isEmpty()) {
                throw new IllegalStateException("이미 존재하는 회원입니다.");
            }
        }
    
        /**
         * 전체 회원 조회
         */
        public List<Member> findMembers() {
            return memberRepository.findAll();
        }
    
        public Member findOne(Long memberId) {
            return memberRepository.findOne(memberId);
        }
    }
    ```
    
    - @Transactional: 외부에서 이 클래스의 메소드를 호출할 때 트랜잭션을 시작하고 메소드를 종료할 때 트랜잭션을 커밋한다. 만약 예외가 발생하면 트랜잭션을 롤백한다. RuntimeException과 그 자식인 Unchecked 예외만 롤백하는데, 체크 예외도 롤백하려면 @Transactional(rollbackFor = Exception.class)처럼 롤백할 예외를 지정한다.
- MemberServiceTest
    - 회원가입 성공
    - 회원가입 할때 같은 이름이 있으면 예외 발생
    
    ```java
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations = "classpath:appConfig.xml")
    @Transactional
    public class MemberServiceTest {
    
        @Autowired MemberService memberService;
        @Autowired MemberRepository memberRepository;
    
        @Test
        public void 회원가입() throws Exception {
    
            //Given
            Member member = new Member();
            member.setName("kim");
    
            //When
            Long saveId = memberService.join(member);
    
            //Then
            assertEquals(member, memberRepository.findOne(saveId));
        }
    
        @Test(expected = IllegalStateException.class) // 이 예외가 발생하면 성공
        public void 중복_회원_예외() throws Exception {
    
            //Given
            Member member1 = new Member();
            member1.setName("kim");
    
            Member member2 = new Member();
            member2.setName("kim");
    
            //When
            memberService.join(member1);
            memberService.join(member2); //예외가 발생해야 한다.
    
            //Then
            fail("예외가 발생해야 한다."); // 얘로 내려오면 실패
        }
    
    }
    ```
    
    - @RunWith(SpringJUnit4ClassRunner.class): 스프링부트와 JUnit5로 작성한 테스트 통합
    - @ContextConfiguration(locations = "classpath:appConfig.xml"): 사용할 스프링정보 등록
    - @Transactional: 테스트가 끝나면 트랜잭션을 강제로 롤백
    
- MemberController
    - 회원가입 폼 내려주기
    - 회원가입
    - 회원 리스트 내려주기
    
    ```java
    @Controller
    public class MemberController {
    
        @Autowired MemberService memberService;
        @Autowired ItemService itemService;
    
        @RequestMapping(value = "/members/new", method = RequestMethod.GET)
        public String createForm() {
            return "members/createMemberForm";
        }
    
        @RequestMapping(value = "/members/new", method = RequestMethod.POST)
        public String create(Member member, String city, String street, String zipcode) {
    
            Address address = new Address(city, street, zipcode);
            member.setAddress(address);
            memberService.join(member);
            return "redirect:/";
        }
    
        @RequestMapping(value = "/members", method = RequestMethod.GET)
        public String list(Model model) {
    
            List<Member> members = memberService.findMembers();
            model.addAttribute("members", members);
            return "members/memberList";
        }
    
    }
    ```
    

## 상품 기능

- 상품 등록
- 상품 목록 조회
- 상품 수정
- Item의 비즈니스 로직
    
    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    @DiscriminatorColumn(name = "DTYPE")
    public abstract class Item {
    
        @Id @GeneratedValue
        @Column(name = "ITEM_ID")
        private Long id;
    
        private String name;        //이름
        private int price;          //가격
        private int stockQuantity;  //재고수량
    
        @ManyToMany(mappedBy = "items")
        private List<Category> categories = new ArrayList<Category>();
    
        //==Biz Method==//
        public void addStock(int quantity) {
            this.stockQuantity += quantity;
        }
    
        public void removeStock(int quantity) {
            int restStock = this.stockQuantity - quantity;
            if (restStock < 0) {
                throw new NotEnoughStockException("need more stock");
            }
            this.stockQuantity = restStock;
        }
    	
    		// Getter Setter ...
    }
    ```
    
    - addStock(): 재고가 증가하거나 상품 주문을 취소한 경우 호출
    - removeStock(): 상품을 주문한 경우 호출. 재고가 부족하면 예외 발생
    
- ItemRepository
    
    ```java
    @Repository
    public class ItemRepository {
    
        @PersistenceContext
        EntityManager em;
    
        public void save(Item item) {
            if (item.getId() == null) { // 추가
                em.persist(item);
            } else { // 수정
                em.merge(item); 
            }
        }
    
        public Item findOne(Long id) {
            return em.find(Item.class, id);
        }
    
        public List<Item> findAll() {
            return em.createQuery("select i from Item i",Item.class).getResultList();
        }
    }
    ```
    
- ItemService
    
    상품 리포지토리에 위임만 하는 단순한 클래스
    
    ```java
    @Service
    @Transactional
    public class ItemService {
    
        @Autowired
        ItemRepository itemRepository;
    
        public void saveItem(Item item) {
            itemRepository.save(item);
        }
    
        public List<Item> findItems() {
            return itemRepository.findAll();
        }
    
        public Item findOne(Long itemId) {
            return itemRepository.findOne(itemId);
        }
    }
    ```
    
- ItemController
    - 아이템 등록 폼 내려주기
    - 아이템 등록하기
    - 아이템 수정 폼 내려주기
    - 아이템 수정하기
    - 상품 목록 내려주기
    
    ```java
    @Controller
    public class ItemController {
    
        @Autowired ItemService itemService;
    
        @RequestMapping(value = "/items/new", method = RequestMethod.GET)
        public String createForm() {
            return "items/createItemForm";
        }
    
        @RequestMapping(value = "/items/new", method = RequestMethod.POST)
        public String create(Book item) {
    
            itemService.saveItem(item);
            return "redirect:/items";
        }
    
        /**
         * 상품 수정 폼
         */
        @RequestMapping(value = "/items/{itemId}/edit", method = RequestMethod.GET)
        public String updateItemForm(@PathVariable("itemId") Long itemId, Model model) {
    
            Item item = itemService.findOne(itemId);
            model.addAttribute("item", item);
            return "items/updateItemForm";
        }
    
        /**
         * 상품 수정
         */
        @RequestMapping(value = "/items/{itemId}/edit", method = RequestMethod.POST)
        public String updateItem(@ModelAttribute("item") Book item) {
    
            itemService.saveItem(item);
            return "redirect:/items";
        }
    
        /**
         * 상품 목록
         */
        @RequestMapping(value = "/items", method = RequestMethod.GET)
        public String list(Model model) {
    
            List<Item> items = itemService.findItems();
            model.addAttribute("items", items);
            return "items/itemList";
        }
    
    }
    ```
    
- 준영속 엔티티 수정하기
    
    ```java
    @RequestMapping(value = "/items/{itemId}/edit", method = RequestMethod.POST)
    public String updateItem(@ModelAttribute("item") Book item) {}
    ```
    
    - 위 코드에서 컨트롤러에 파라미터로 넘어온 Book은 준영속 상태이므로 영속성 컨텍스트의 지원을 받을 수 없으며, 데이터를 수정해도 dirty checking이 감지되지 않는다.
    - 따라서 변경 감지 기능을 사용하거나 병합을 사용한다.
    
    ```java
    // 변경 감지 기능: 특정 필드만 수정할 수 있다
    Item findItem = em.find(Item.class, itemParam.getId());
    findItem.setPrice(itemParam.getPrice());
    ```
    
    ```java
    // 병합 사용: 전체 필드를 덮어쓰기한다
    Item mergeItem = em.merge(item);
    ```
    
    우리가 작성한 상품 레포지토리는 준영속 상태의 엔티티를 수정하는 경우 병합을 수행한다.
    
    ```java
    public void save(Item item) {
    		if (item.getId() == null) { // 추가
    				em.persist(item);
    		} else { // 수정
    				em.merge(item); 
    		}
    }
    ```
    

## 주문 기능

- 상품 주문
- 주문 내역 조회
- 주문 취소
- Order의 비즈니스 로직
    
    ```java
    @Entity
    @Table(name = "ORDERS")
    public class Order {
    
        @Id @GeneratedValue
        @Column(name = "ORDER_ID")
        private Long id;
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "MEMBER_ID")
        private Member member;      //주문 회원
    
        @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
        private List<OrderItem> orderItems = new ArrayList<OrderItem>();
    
        @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
        @JoinColumn(name = "DELIVERY_ID")
        private Delivery delivery;  //배송정보
    
        private Date orderDate;     //주문시간
    
        @Enumerated(EnumType.STRING)
        private OrderStatus status;//주문상태
    
        //==생성 메서드==//
        public static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems) {
    
            Order order = new Order();
            order.setMember(member);
            order.setDelivery(delivery);
            for (OrderItem orderItem : orderItems) {
                order.addOrderItem(orderItem);
            }
            order.setStatus(OrderStatus.ORDER);
            order.setOrderDate(new Date());
            return order;
        }
    
        //==비즈니스 로직==//
        /** 주문 취소 */
        public void cancel() {
    
            if (delivery.getStatus() == DeliveryStatus.COMP) {
                throw new RuntimeException("이미 배송완료된 상품은 취소가 불가능합니다.");
            }
    
            this.setStatus(OrderStatus.CANCEL);
            for (OrderItem orderItem : orderItems) {
                orderItem.cancel();
            }
        }
    
        //==조회 로직==//
        /** 전체 주문 가격 조회 */
        public int getTotalPrice() {
            int totalPrice = 0;
            for (OrderItem orderItem : orderItems) {
                totalPrice += orderItem.getTotalPrice();
            }
            return totalPrice;
        }
    
    		// Getter Setter ...
    }
    ```
    
    - cancel(): 주문 취소시 호출. 주문 상태를 취소로 변경하고 주문 상품에 취소를 알린다. 이미 배송을 완료한 상품이면 주문을 취소하지 못하도록 예외를 발생시킨다.
    - getTotalPrice(): 각각의 주문상품 가격을 조회해서 더한다.
    
- OrderItem의 비즈니스 로직
    
    ```java
    @Entity
    @Table(name = "ORDER_ITEM")
    public class OrderItem {
    
        @Id @GeneratedValue
        @Column(name = "ORDER_ITEM_ID")
        private Long id;
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "ITEM_ID")
        private Item item;      //주문 상품
    
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "ORDER_ID")
        private Order order;    //주문
    
        private int orderPrice; //주문 가격
        private int count;      //주문 수량
    
        //==생성 메서드==//
        public static OrderItem createOrderItem(Item item, int orderPrice, int count) {
            OrderItem orderItem = new OrderItem();
            orderItem.setItem(item);
            orderItem.setOrderPrice(orderPrice);
            orderItem.setCount(count);
    
            item.removeStock(count);
            return orderItem;
        }
    
        //==비즈니스 로직==//
        /** 주문 취소 */
        public void cancel() {
            getItem().addStock(count);
        }
    
        //==조회 로직==//
        /** 주문상품 전체 가격 조회 */
        public int getTotalPrice() {
            return getOrderPrice() * getCount();
        }
    
        //==Getter, Setter==//
    }
    ```
    
    - createOrderItem(): 필드 최기화, 주문한 수량만큼 해당 상품 재고 줄이기
    - cancel(): 취소한 수량만큼 상품 재고를 증가시키는 메소드 호출. Order의 비즈니스 로직에서 호출된다.
    - getTotalPrice(): 주문 가격에 수량을 곱한 값을 반환한다. Order의 비즈니스 로직에서 호출된다.
    
- OrderRepository (주문 검색 기능)
    
    ```java
    @Repository
    public class OrderRepository {
    
        @PersistenceContext
        EntityManager em;
    
        public void save(Order order) {
            em.persist(order);
        }
    
        public Order findOne(Long id) {
            return em.find(Order.class, id);
        }
    
        public List<Order> findAll(OrderSearch orderSearch) { // 주문 검색
    
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Order> cq = cb.createQuery(Order.class);
            Root<Order> o = cq.from(Order.class);
    
            List<Predicate> criteria = new ArrayList<Predicate>();
    
            //주문 상태 검색
            if (orderSearch.getOrderStatus() != null) {
                Predicate status = cb.equal(o.get("status"), orderSearch.getOrderStatus());
                criteria.add(status);
            }
            //회원 이름 검색
            if (StringUtils.hasText(orderSearch.getMemberName())) {
                Join<Order, Member> m = o.join("member", JoinType.INNER); //회원과 조인
                Predicate name = cb.like(m.<String>get("name"), "%" + orderSearch.getMemberName() + "%");
                criteria.add(name);
            }
    
            cq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));
            TypedQuery<Order> query = em.createQuery(cq).setMaxResults(1000); //최대 검색 1000 건으로 제한
            return query.getResultList();
        }
    }
    ```
    
- OrderService
    
    ```java
    @Service
    @Transactional
    public class OrderService {
    
        @Autowired MemberRepository memberRepository;
        @Autowired OrderRepository orderRepository;
        @Autowired ItemService itemService;
    
        /** 주문 */
        public Long order(Long memberId, Long itemId, int count) {
    
            //엔티티 조회
            Member member = memberRepository.findOne(memberId);
            Item item = itemService.findOne(itemId);
    
            //배송정보 생성
            Delivery delivery = new Delivery(member.getAddress());
            //주문상품 생성
            OrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);
            //주문 생성
            Order order = Order.createOrder(member, delivery, orderItem);
    
            //주문 저장
            orderRepository.save(order);
            return order.getId();
        }
    
        /** 주문 취소 */
        public void cancelOrder(Long orderId) {
    
            //주문 엔티티 조회
            Order order = orderRepository.findOne(orderId);
    
            //주문 취소
            order.cancel();
        }
    
        /** 주문 검색 */
        public List<Order> findOrders(OrderSearch orderSearch) {
            return orderRepository.findAll(orderSearch);
        }
    
    }
    ```
    
- OrderSearch
    
    
    검색 관련 기능만 모아서 한번에 보자.
    
    Repository: 검색 조건에 따라 Criteria를 동적으로 생성해서 주문 엔티티 조회
    
    ```java
    public List<Order> findAll(OrderSearch orderSearch) { // 주문 검색
    		CriteriaBuilder cb = em.getCriteriaBuilder();
    		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
    		Root<Order> o = cq.from(Order.class);
    
    		List<Predicate> criteria = new ArrayList<Predicate>();
    
    		//주문 상태 검색
    		if (orderSearch.getOrderStatus() != null) {
    				Predicate status = cb.equal(o.get("status"), orderSearch.getOrderStatus());
    				criteria.add(status);
    		}
    
    		//회원 이름 검색
    		if (StringUtils.hasText(orderSearch.getMemberName())) {
    				Join<Order, Member> m = o.join("member", JoinType.INNER); //회원과 조인
    				Predicate name = cb.like(m.<String>get("name"), "%" + orderSearch.getMemberName() + "%");
    				criteria.add(name);
    		}
    
    		cq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));
    		TypedQuery<Order> query = em.createQuery(cq).setMaxResults(1000); //최대 검색 1000 건으로 제한
    		return query.getResultList();
    }
    ```
    
    Service
    
    ```java
    public List<Order> findOrders(**OrderSearch orderSearch**) {
    		return orderRepository.findAll(orderSearch);
    }    
    ```
    
    OrderSearch: 검색 조건을 가진 객체
    
    - 회원 이름
    - 주문 상태: 주문, 취소
    
    ```java
    public class OrderSearch {
    
        private String memberName;      //회원 이름
        private OrderStatus orderStatus;//주문 상태
    
        //Getter, Setter
        public String getMemberName() {
            return memberName;
        }
    
        public void setMemberName(String memberName) {
            this.memberName = memberName;
        }
    
        public OrderStatus getOrderStatus() {
            return orderStatus;
        }
    
        public void setOrderStatus(OrderStatus orderStatus) {
            this.orderStatus = orderStatus;
        }
    }
    ```
    
- OrderServiceTest
    - 상품 주문이 성공해야 한다.
    - 상품을 주문할 때 재고 수량을 초과하면 안된다.
    - 주문 취소가 성공해야 한다.
    
    ```java
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations = "classpath:appConfig.xml")
    @Transactional
    //@TransactionConfiguration(defaultRollback = false)
    public class OrderServiceTest {
    
        @PersistenceContext
        EntityManager em;
    
        @Autowired OrderService orderService;
        @Autowired OrderRepository orderRepository;
    
        @Test
        public void 상품주문() throws Exception {
    
            //Given
            Member member = createMember();
            Item item = createBook("시골 JPA", 10000, 10); //이름, 가격, 재고
            int orderCount = 2;
    
            //When
            Long orderId = orderService.order(member.getId(), item.getId(), orderCount);
    
            //Then
            Order getOrder = orderRepository.findOne(orderId);
    
            assertEquals("상품 주문시 상태는 주문(ORDER)이다.", OrderStatus.ORDER, getOrder.getStatus());
            assertEquals("주문한 상품 종류 수가 정확해야 한다.", 1, getOrder.getOrderItems().size());
            assertEquals("주문 가격은 가격 * 수량이다.", 10000 * 2, getOrder.getTotalPrice());
            assertEquals("주문 수량만큼 재고가 줄어야 한다.", 8, item.getStockQuantity());
        }
    
        @Test(expected = NotEnoughStockException.class)
        public void 상품주문_재고수량초과() throws Exception {
    
            //Given
            Member member = createMember();
            Item item = createBook("시골 JPA", 10000, 10); //이름, 가격, 재고
    
            int orderCount = 11; //재고 보다 많은 수량
    
            //When
            orderService.order(member.getId(), item.getId(), orderCount);
    
            //Then
            fail("재고 수량 부족 예외가 발생해야 한다.");
        }
    
        @Test
        public void 주문취소() {
    
            //Given
            Member member = createMember();
            Item item = createBook("시골 JPA", 10000, 10); //이름, 가격, 재고
            int orderCount = 2;
    
            Long orderId = orderService.order(member.getId(), item.getId(), orderCount);
    
            //When
            orderService.cancelOrder(orderId);
    
            //Then
            Order getOrder = orderRepository.findOne(orderId);
    
            assertEquals("주문 취소시 상태는 CANCEL 이다.", OrderStatus.CANCEL, getOrder.getStatus());
            assertEquals("주문이 취소된 상품은 그만큼 재고가 증가해야 한다.", 10, item.getStockQuantity());
        }
    
    		// 공통으로 사용할 creator
        private Member createMember() {
            Member member = new Member();
            member.setName("회원1");
            member.setAddress(new Address("서울", "강가", "123-123"));
            em.persist(member);
            return member;
        }
    
        private Book createBook(String name, int price, int stockQuantity) {
            Book book = new Book();
            book.setName(name);
            book.setStockQuantity(stockQuantity);
            book.setPrice(price);
            em.persist(book);
            return book;
        }
    }
    ```
    
- OrderController
    - 주문 폼 내려주기
    - 주문하기
    - 주문 목록 내려주기
    - 주문 취소하기
    
    ```java
    @Controller
    public class OrderController {
    
        @Autowired OrderService orderService;
        @Autowired MemberService memberService;
        @Autowired ItemService itemService;
    
        @RequestMapping(value = "/order", method = RequestMethod.GET)
        public String createForm(Model model) {
    
            List<Member> members = memberService.findMembers();
            List<Item> items = itemService.findItems();
    
            model.addAttribute("members", members);
            model.addAttribute("items", items);
    
            return "order/orderForm";
        }
    
        @RequestMapping(value = "/order", method = RequestMethod.POST)
        public String order(@RequestParam("memberId") Long memberId, @RequestParam("itemId") Long itemId, @RequestParam("count") int count) {
    
            orderService.order(memberId, itemId, count);
            return "redirect:/orders";
        }
    
        @RequestMapping(value = "/orders", method = RequestMethod.GET)
        public String orderList(@ModelAttribute("orderSearch") OrderSearch orderSearch, Model model) {
    
            List<Order> orders = orderService.findOrders(orderSearch);
            model.addAttribute("orders", orders);
    
            return "order/orderList";
        }
    
        @RequestMapping(value = "/orders/{orderId}/cancel")
        public String processCancelBuy(@PathVariable("orderId") Long orderId) {
    
            orderService.cancelOrder(orderId);
    
            return "redirect:/orders";
        }
    }
    ```
